[<< back](../README.md)

```
Fecha: 20260108
Autor: David Vargas
```

# Las ACL en GNU/Linux

Las ACL son listas de control de accesos. Es otra forma de asignar permisos con otro nivel de detalle similar al empleado en los Routers Cisco y en el sistema de ficheros NTFS.

Hay que instalar el paquete `acl`, que contiene los comandos:
* `getfacl`, consultar las ACL.
* `setfacl`, modificar las ACL.

# 1. El paquete ACL de la distribución

> Enlace de interés:
> * [Actividad: permisos ACL en Debian](https://github.com/dvarrui/libro-de-actividades/blob/master/actividades/sistemas.2/permisos/permisos-acl-debian.md)
>
> Repo paquete ACL: 
> * https://cgit.git.savannah.gnu.org/cgit/acl.git
> * git://git.git.savannah.gnu.org/acl.git
> * ssh://git.savannah.gnu.org/srv/git/acl.git

## 1.1 Ejemplo

Veamos un ejemplo del clásico permiso user-group-others:

```bash
$ vdir
total 4
-rwxr-xr-x 1 david david 19 2011-02-03 22:52 holamundo*
```

Ahora veamos un ejemplo de permisos ACL con getfacl:
```bash
$ getfacl holamundo
# file: holamundo
# owner: david
# group: david
user::rwx
group::r-x
other::r-x
```

## 1.2 Activación manual

ACL añade más detalle al sistema clásico de permisos, pero para poder usar el comando `setfacl`, los ficheros deben estar en un sistema de ficheros montado con la opción `acl`. Por ejemplo si intentamos establecer permisos ACL sin haber activado antes el sistema de ficheros en modo `acl` veremos un error como este: `setfacl: holamundo: La operación no está soportada`.

Si quisiéramos habilitar ACL de manera temporal para la sesión actual, ejecutamos el siguiente comando:

```bash
mount /dev/partition -o defaults,acl /punto/de/montaje
```

Ahora podemos usar el comando mount sin parámetros para verificar que todo está montado según nuestras intenciones. Ya podemos usar el comando `setfacl` para añadir permiso de lectura
al usuario `invitado` sobre el fichero `holamundo`.

```
$ vdir
total 4
-rwxr-xr-x 1 david david 19 2011-02-03 22:52 holamundo*
$ setfacl -m u:invitado:r holamundo
```

Explicación de los parámetros del comando:

| Parámetro | Descripción |
| --------- | ----------- |
| setfacl   | Comando para poner permisos ACL |
| -m        | Modificar ACL |
| u         | Modificar un usuario  |
| invitado  | Usuario invitado |
| r         | Permiso de lectura |
| holamundo | Nombre del fichero |

* Ejecutamos `getfacl` para comprobar que el resultado es el que esperábamos.

```bash
$ getfacl holamundo
# file: holamundo
# owner: david
# group: david
user::rwx
user:invitado:r--
group::r-x
mask::r-x
other::r-x
```

> Para quitar los permisos hacemos `setfacl -x u:invitado holamundo`. Sencillo, ¿verdad?

## 1.3 Activación automática

Para que se habiliten las ACL en la partición que elijamos de forma automática al iniciar el equipo, debemos modificar el fichero `/etc/fstab`, y luego reiniciar el equipo. Este fichero define que particiones serán montadas automáticamente al iniciar el sistema, y con qué parámetros se realizará dicho montaje automático.

Ejemplo de como editar el fichero `/etc/fstab` para activar las ACL en las particiones deseadas de manera permanente:

`/dev/partición  /punto/de/montaje ext2 defaults,acl 0 2`

> En este ejemplo se asume que la partición que estamos montando tiene formato `ext2`, pero podría ser cualquier otro (Podemos usar el comando `df -hT` para ver tipo de formato que tiene cada partición).

Tras haber modificado `/etc/fstab`, es necesario reiniciar la máquina (comando reboot) para que surtan efecto los cambios.

# 2. Simulando ACL

Reflexionando sobre las funcionalidades que nos ofrece el paquete `acl` para obtener permisos de granularidad más fina (Access Control List), se me ocurre "experimentar" con los permisos estándar de los sistemas de ficheros GNU/Linux ("owner-group-others") a ver si podemos conseguir un "efecto" similar a las ACL. Vamos allá.

## 2.1 Situación de partida

Supongamos que tenemos las siguientes carpetas de los proyectos:

```
proyectos
├── proy_a
│   └── a.txt
├── proy_b
│   └── b.txt
└── proy_c
    └── c.txt
```

## 2.2 Grupos de permisos

Ahora creamos los grupos siguientes:

| Grupo     | Permisos       | Carpeta |
| --------- | -------------- | ------ |
| ro_proy_a | Read only      | proy_a |
| rw_proy_a | Read and write | proy_a |
| ro_proy_b | Read only      | proy_b |
| rw_proy_b | Read and write | proy_b |
| ro_proy_c | Read only      | proy_c |
| rw_proy_c | Read and write | proy_c |

De modo que si un usuario lo ponemos en los grupos `ro_proy_a` y `rw_pry_b`, tendrá permisos de lectura en el proyecto A, lectura y escritura en el proyecto B y ningún acceso en el proyecto C. Podemos saber los permisos asignados:
* Consultando el fichero `/etc/group`
* O mediante el comando `id USERNAME`

Para que todo esto funcione, habría que poder asignar a una misma carpeta permisos diferentes para el grupo `ro_XXX` y para el grupo `rw_XXX`... pero esto no es posible. Sólo podemos asignar permisos de grupo a la carpeta una única vez... seguimos pensando otra idea...

## 2.3 Los enlaces simbólicos

Creamos un enlace simbólico a cada proyecto con el mismo nombre del proyecto pero con el sufio `_ro`. Porque usaremos las carpetas originales para asignar permisos de escritura y los enlaces simbólicos para los permisos de lectura.

```
.
├── proy_a
│   └── a.txt
├── proy_a_ro -> proy_a
├── proy_b
│   └── b.txt
├── proy_b_ro -> proy_b
├── proy_c
│   └── c.txt
└── proy_c_ro -> proy_c
```

Creamos los grupos del apartado 2.2

```bash
sudo groupadd rw_proy_a
sudo chgrp rw_proy_a proy_a

sudo groupadd ro_proy_a 
sudo chgrp ro_proy_a proy_a_ro
```

```bash
# vdir
total 0
drwxr-xr-x 2 david rw_proy_a 19 ene 20 18:45 proy_a
lrwxrwxrwx 1 david david      6 ene 20 18:47 proy_a_ro -> proy_a
drwxr-xr-x 2 david david     19 ene 20 18:48 proy_b
lrwxrwxrwx 1 david david      6 ene 20 18:48 proy_b_ro -> proy_b
drwxr-xr-x 2 david david     19 ene 20 18:45 proy_c
lrwxrwxrwx 1 david david      6 ene 20 18:48 proy_c_ro -> proy_c
```

Vaya... ¡no funciona! ¿No podemos asignarle permisos de grupo a un enlace simbólico?

## 2.4 Permisos de lectura

De momento, lo único que hemos conseguido es asignar permisos de escritura a los usuarios por proyectos, simplemente agregándolos como miemnbros de los grupos respectivos:

| Grupo     | Permisos       | Carpeta |
| --------- | -------------- | ------- |
| rw_proy_a | Read and write | proy_a  |
| rw_proy_b | Read and write | proy_b  |
| rw_proy_c | Read and write | proy_c  |

¿Pero y cómo resolvemos el problema de la lectura? mmm ¡Quizás no hay que hacer nada especial! Me explico. Resulta que los proyectos los tenemos en repositorios de Git, entonces tendremos:

| Usuarios de Git                   | Usuario del sistema                     |
| --------------------------------- | --------------------------------------- |
| Con permisos de escritura en Git  | Con permisos de escritura en la carpeta |
| Con permisos de lectura en Git    | Sin permisos        |

Esto simplemente significa que los usuarios de lectura sólo pueden leer el repositorio pero no pueden leer en el sistema de ficheros. Ahora basta que los usuarios de lectura se clonen el repo en su carpeta local y listo. Ya tienen una lectura "privada".
