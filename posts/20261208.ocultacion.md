
# Ocultación por "protocolo"

## 1. Definición

La ocultación es un principio de diseño de software que consiste en proteger y esconder los detalles internos de cómo funciona un objeto (o estructura de datos), permitiendo que sólo se pueda interactuar con él a través de una interfaz controlada.

Su objetivo es la abstracción: que el resto del programa no dependa de cómo guardas los datos.

Niveles de ocultación:
* **Ocultación de Datos**: Impide que el estado interno (las variables) sea modificado directamente desde fuera.
* **Ocultación de Implementación**: Esconde los algoritmos o la lógica compleja. Al usuario del objeto solo le importa el resultado, no los pasos intermedios.
* **Ocultación de Diseño**: Permite cambiar la estructura interna de una clase sin que los programas que la usan tengan que ser modificados.

Supongamos que tenemos el ejemplo de conducir un coche, la ocultación separa los pedales y el volante (la interfaz) del motor y la inyección (la implementación).
* **Mantenibilidad**: Si el fabricante decide cambiar el motor de gasolina por uno eléctrico, tú sigues usando los mismos pedales. El sistema no se rompe porque la implementación está oculta tras la interfaz.
* **Seguridad de Estado**: Evita que alguien ponga el contador de velocidad en -100 km/h directamente. El objeto solo permite cambios a través de métodos que validan la información.
* **Reducción de la Complejidad**: El programador que usa tu objeto no necesita entender 500 líneas de código interno; solo necesita saber qué mensaje enviar.

A menudo se confunde la encapsulamiento con la ocultación, pero ahora nos vamos a centrar en la segunda.

* Encapsulamiento: Es el acto de agrupar los datos y los métodos en una misma cápsula.
* Ocultación: Es el acto de restringir el acceso a esa cápsula para que algunas partes sean privadas y otras públicas.

En resumen: El encapsulamiento es la caja, y la ocultación es el candado que decide quién puede mirar dentro de la caja.

## 2. Tipos de ocultación

Podríamos decir que los lenguaje de programación tienen alguno de los siguientes tipos de ocultación:
* **Privacidad explícita**: es necesario usar keywords como "public" o "private" para especificar la ocultación. Ejemplo: C++. Java, Simula.
* **Privacidad por defecto**: Los atributos son siempre privados. Es necesario crear "getters/setters" para acceder a los atributos. Ejemplo: Smalltalk, Ruby.
* **Privacidad por protocolo**: Los atributos son siempre visibles pero por protocolo los programadores deciden respetar la privacidada. Ejemplo: Python, Perl, Lua.

Históricamente podemos decir que Simula 67 fue el primer lenguaje en introducir los conceptos de Clases y Objetos, pero en sus primeras implementaciones no tenía ocultación. Si tenía herencia pero era "herencia simple", para garantizar que el camino hacia arriba en la jerarquía fuera único y predecible.

A medida que el lenguaje evolucionó (en revisiones posteriores de los años 70), se dieron cuenta de que necesitaban un control más fino para proteger la integridad de los datos e introdujeron las palabras clave HIDDEN (private) y PROTECTED.

## 3. Ocultación por "protocolo"

Mientras algunos lenguajes (como C++ o Java) crean una estructura rígida en memoria para una clase, en Python, se implementan mediante diccionarios. Si miramos el atributo `__dict__`. La "apariencia" de objeto es en realidad una capa sintáctica sobre una búsqueda en una tabla hash (Diccionario).

Cuando hacemos `self.nombre = "Vader"`, entre bastidores ocurre lo siguiente:

```python
# Lo que escribes:
usuario.nombre = "Vader"

# Lo que Python hace realmente:
usuario.__dict__["nombre"] = "Vader"
```

Tenemos que tanto los objetos como las clases se basan en diccionarios:
* El Objeto: Guarda sus datos (atributos de instancia) en un diccionario.
* La Clase: Guarda el comportamiento (las funciones) en un diccionario.

Cuando se llama al "método" `usuario.saludar()`, ocurre lo siguiente:

```python
usuario.saludar()
├── usuario.__class__           #=> class '__main__.Persona'>
├── Persona.saludar(usuario)    #=> Azúcar sintáctico como llamada de funciones
├── Persona.__dict__["saludar"] #=> Se localiza la función
└── Persona.__dict__["saludar"](usuario) #=> Se ejecuta la función
```

Resumiendo:
1. Se obtiene la referencia de la clase del objeto.
2. Se aplica azúcar sintáctico.
3. Se busca en el `__dict__` de la clase la función `saludar()`.
4. Si no se encuentra, entonces se busca en el `__dict__` de la clase padre.
5. Se ejecuta la función pasando como parámetro el objeto "invocador".

Es necesario que no exista ocultación en el lenguaje para que funcione la creación de atributos específicos del objeto en tiempo de ejecución. Ejemplo
```python
class Persona:
  def __init__(self, nombre):
    self.nombre = nombre

vader = Persona("Vader")
type(vader)     #=> <class '__main__.Persona'>
vader.__dict__  #=> {'nombre': 'Vader'}

# CREACION DE UN ATRIBUTO DE OBJETO QUE NO ESTA EN LA CLASE
vader.rol = "sith"
vader.__dict__  #=> {'nombre': 'Vader', 'rol': 'sith'}

vader.__dict__['film'] = 'Starwars'
vader.__dict__  #=> {'nombre': 'Vader', 'rol': 'sith', 'film': 'Starwars'}
```

Python permite añadir atributos a un objeto en tiempo de ejecución (usuario.edad = 30 sin que la clase tenga "edad"), ya que el objeto se basa en un diccionario abierto.

# 4. La "herencia" múltiple

Sabía que C++ tenía herencia mútiple pero no sabía que Python también lo tenía. ¿Cómo se gestiona el problema de la herencia en diamante?

Supongamos que tenemos el siguiente ejemplo: 
* la Clase A es el padre
* B y C heredan de A, 
* y la Clase D hereda de B y C.

```python
class A:
    def saludar(self): print("Hola desde A")

class B(A):
    def saludar(self): print("Hola desde B")

class C(A):
    def saludar(self): print("Hola desde C")

class D(B, C):
    pass

d = D()
d.saludar() #=> ¿Qué imprime? 
```

En el objeto D tendremos el siguiente orden de diccionarios en los que se debe buscar: D -> B -> C -> A -> object (Lista MRO)

> **OJO**: Si se cambia `class D(B, C)` por `class D(C, B)`, el comportamiento del programa cambia radicalmente. La semantica cambia según la posición de una coma, no de la estructura del sistema.

## 5. El super() método

En la mayoría de los lenguajes, `super()` significa "llama a mi padre". En Python, `super()` significa "llama al siguiente diccionario en la lista de los ancestros (Lista MRO)".

Problema:
* Situación esperada: Cuando la clase B llama a `super().saludar()`, se espera que llame a A (su padre).
* Situación sorpresa: Pero si estás en la clase D, el `super()` de B ¡salta a la clase C! (que es su "hermana", no su padre).

Ejemplo:

```python
class A:
  def saludar(self): print("Hola desde A")
 
class B(A):
  def saludar(self): super().saludar()
 
class C(A):
  def saludar(self): print("Hola desde C")
 
class D(B, C):
  pass
 
d = D()
d.saludar() #=> Hola desde C
```

Si un desarrollador lee la clase B de forma aislada, cree entender el flujo pero los que ocurre es que ese flujo es "secuestrado" por el orden de resolución de métodos de la clase que herede de ella. 

Todo esto, hace complicado predecir el comportamiento de un método solo leyendo la clase. Se necesita conocer toda la jerarquía de herencia de todos los ancestros y calcular mentalmente el algoritmo C3(MRO) para saber qué diccionario se consultará después.

## 6. El problema del "salto lateral"

El apartado anterior explica una situación que genera confusión pero esto nos puede llevar a un problema en el código. Veamos.

El problema ocurre porque `super()` no significa "padre", significa "siguiente en la fila" de los ancestros, y esa fila se decide en la clase final, no en la clase donde escribes el código.

Imaginemos que tenmos un sistema de procesamiento de pagos. Tenemos una clase base y un Mixin diseñado para aplicar impuestos. El desarrollador del cree que está extendiendo la funcionalidad base, pero en realidad, está a merced de cómo otros combinen las piezas.

```python
class ProcesadorBase:
  def __init__(self):
    print("1. Iniciando Procesador Base")
    self.total = 100

class MixinImpuestos(ProcesadorBase):
  def __init__(self):
    print("2. Aplicando Impuestos (Mixin)")
    super().__init__()  # ¿A quién llama esto?
    self.total += 21

class MixinDescuento(ProcesadorBase):
  def __init__(self):
    print("3. Aplicando Descuento (Mixin)")
    # ERROR: Olvidar super() o asumir que llama a Base
    super().__init__()
    self.total = 80 

class PagoFinal(MixinImpuestos, MixinDescuento):
  def __init__(self):
    super().__init__()

a = PagoFinal()
# Output:
# 2. Aplicando Impuestos (Mixin)
# 3. Aplicando Descuento (Mixin)
# 1. Iniciando Procesador Base
a.__dict__ #=> {'total': 101}
```

El recorrido de los ancestros PagoFinal es: [PagoFinal, MixinImpuestos, MixinDescuento, ProcesadorBase, object]
* PagoFinal llama a super(), que salta a MixinImpuestos.
* MixinImpuestos ejecuta su lógica y llama a super(). El desarrollador de este Mixin cree que está llamando a ProcesadorBase (porque heredó de él), pero el algoritmo le dice que el siguiente es MixinDescuento.
* MixinDescuento se ejecuta y llama a super(), que finalmente llega a ProcesadorBase, el cual hace self.total = 100.
* MixinDescuento se ejecuta y aquí ocurre la corrupción de datos. Este Mixin sobreescribe self.total = 80.
* MixinImpuestos hace su suma 80 + 21 y queda 101.

> Este es el escenario donde la "magia" de los diccionarios y la linealización del algoritmo de los ancestroa se convierten en un problema.

* Violación de la ocultación: Al leer MixinImpuestos, parece que su comportamiento es predecible. Sin embargo, su éxito depende de que MixinDescuento (una clase que ni siquiera conoce) se comporte bien.
* Dependencia del Orden de Comas: Si el desarrollador de PagoFinal escribe (MixinDescuento, MixinImpuestos), el resultado matemático será totalmente distinto. La lógica de negocio queda relegada al orden de una lista de herencia múltiple.
* Estado inconsistente: Debido a que todos comparten el mismo diccionario de instancia (self.__dict__), cualquier clase en la lista de ancestroa puede "limpiar" o corromper los datos de las demás sin dejar rastro.

En los frameworks que usan clases que heredan de varios Mixins. Si uno de esos Mixins en medio hace llamadas en el orden incorrecto, los otros Mixins dejan de funcionar silenciosamente. No hay error de compilación, simplemente los datos aparecen "corruptos" o incompletos.

## 7. Conclusión personal

En la medida de lo posible, sería recomendable evitar la programación orientada a objetos en Python o en su defecto evitar la herencia múltiple.
